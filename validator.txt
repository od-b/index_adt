
#define T_WORD    0
#define O_ANDNOT  1
#define O_AND     2
#define O_OR      3
#define P_OPEN    -1
#define P_CLOSE   -2

static int word_type(char *token) {
    size_t len = strlen(token);

    if (len > 6)
        return T_WORD;
    if (len == 2) {
        if (token[0] == '(')
            return P_OPEN;
        if (token[0] == ')')
            return P_CLOSE;
        return T_WORD;
    }

    if (strcmp(token, "AND") == 0)
        return O_AND;
    if (strcmp(token, "OR") == 0)
        return O_OR;
    if (strcmp(token, "ANDNOT") == 0)
        return O_ANDNOT;
    return T_WORD;
}

/* 
* Checks whether a query is syntactically valid. Returns a bool.
* There might be edge cases that this function will miss.
*/
static int is_valid_query(index_t *index, list_t *query, char **errmsg) {
    list_iter_t *q_iter = list_createiter(query);
    if (q_iter == NULL) {
        *errmsg = "index out of memory";
        return 0;
    }

    int prev_type, n_par_open = 0, n_par_close = 0, last_operator = 0;
    int n_tokens = list_size(query);
    char *prev = NULL;
    char *curr = list_next(q_iter);
    int curr_type = word_type(curr);

    if (n_tokens == 1) {
        if (curr_type == T_WORD) {
            /* single term word query - valid */
            list_destroyiter(q_iter);
            return 1;
        }
        *errmsg = "Single term queries must be a word.";
        goto error;
    }
    if ((curr_type != T_WORD) && (curr_type != P_OPEN)) {
        *errmsg = "Search must begin with an opening paranthesis or word.";
        goto error;
    }

    /*
    * Parantheses types are defined as < 0
    * Operator types are > 0
    */

    while (list_hasnext(q_iter)) {
        if (curr_type < 0) {
            /* current token is a paranthesis, forget the last operator */
            last_operator = 0;

            if (curr_type == P_OPEN) {
                n_par_open++;
            }
            else if (curr_type == P_CLOSE) {
                n_par_close++;
            }
        }
        else if (curr_type > 0) {
            /* current token is an operator */

            if (prev != NULL) {
                if (last_operator && (last_operator != curr_type)) {
                    *errmsg = "different types of operators must be separated by parantheses.";
                    goto error;
                }
                if (prev_type > 0) {
                    *errmsg = "adjacent operators";
                    goto error;
                }
            }
            /* remember current operator for when the next operator comes */
            last_operator = curr_type;
        }

        prev = curr;
        prev_type = curr_type;
        curr = list_next(q_iter);
        curr_type = word_type(curr);
    }

    if ((curr_type != T_WORD) && (curr_type != P_CLOSE)) {
        if (curr_type == P_OPEN) 
            *errmsg = "A query may not end with an opening paranthesis.";
        else
            *errmsg = "A query may not end with an operator.";
        goto error;
    } 
    
    if (n_par_open != n_par_close) {
        *errmsg = "Opening and closing paranthesis counts do not match.";
        goto error;
    } 

    list_destroyiter(q_iter);
    return 1;

error:
    /* typically wont use goto, but i believe it improves readability here */
    list_destroyiter(q_iter);
    return 0;
}

static int is_valid_query(index_t *index, list_t *query, char **errmsg) {
    list_iter_t *q_iter = list_createiter(query);
    if (q_iter == NULL) {
        *errmsg = "index out of memory";
        return 0;
    }

    int prev_type, n_par_open = 0, n_par_close = 0, last_operator = 0;
    int n_tokens = list_size(query);
    char *prev = NULL;
    char *curr = list_next(q_iter);
    int curr_type = word_type(curr);

    if (n_tokens == 1) {
        if (curr_type == T_WORD) {
            /* single term word query - valid */
            list_destroyiter(q_iter);
            return 1;
        }
        *errmsg = "Single term queries must be a word.";
        goto error;
    }
    if ((curr_type != T_WORD) && (curr_type != P_OPEN)) {
        *errmsg = "Search must begin with an opening paranthesis or word.";
        goto error;
    }

    /*
    * Parantheses types are defined as < 0
    * Operator types are > 0
    */

    while (list_hasnext(q_iter)) {
        if (curr_type < 0) {
            /* current token is a paranthesis, forget the last operator */
            last_operator = 0;

            if (curr_type == P_OPEN) {
                n_par_open++;
            }
            else if (curr_type == P_CLOSE) {
                n_par_close++;
            }
        }
        else if (curr_type > 0) {
            /* current token is an operator */

            if (prev != NULL) {
                if (last_operator && (last_operator != curr_type)) {
                    /* different types of operators must be separated by parantheses */
                    if (prev_type == T_WORD) {
                        *errmsg = "different types of operators must be separated by parantheses.";
                        goto error;
                    }
                    else if (prev_type == curr_type) {
                        *errmsg = "adjacent operators.";
                        goto error;
                    }
                }
            }
            /* remember current operator for when the next operator comes */
            last_operator = curr_type;
        }

        prev = curr;
        prev_type = curr_type;
        curr = list_next(q_iter);
        curr_type = word_type(curr);
    }

    if ((curr_type != T_WORD) && (curr_type != P_CLOSE)) {
        if (curr_type == P_OPEN) 
            *errmsg = "A query may not end with an opening paranthesis.";
        else
            *errmsg = "A query may not end with an operator.";
        goto error;
    } 
    
    if (n_par_open != n_par_close) {
        *errmsg = "Opening and closing paranthesis counts do not match.";
        goto error;
    } 

    list_destroyiter(q_iter);
    return 1;

error:
    /* typically wont use goto, but i believe it improves readability here */
    list_destroyiter(q_iter);
    return 0;
}