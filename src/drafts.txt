/*  deny invalid query without giving a good reason. still invalid tho.

    if (list_size(query) % 2 == 0) {
        /* Any given valid query will always have an odd number of tokens. Reasoning:
        * '<word> <word>' results in the indexer adding an "OR" inbetween.
        * As a consequence of this, all words must (or will, for "OR"), be connected by an operator.
        * Every operator must have adjacent terms, and parantheses must occur in multiples of 2.
        * => for every word, operator or parantheses added in addition to the 'root' word, n_tokens will 
        * be incremented by 2 if query is valid, and |tokens| will therefore never be even */
        *errmsg = "Invalid use of parantheses or operators.";
        return NULL;
    }

*/


/*  compare indexed chars

int compare_chars(char *a, char *b) {
    if (a[0] < b[0]) return -1;
    if (a[0] > b[0]) return 1;
    return 0;
}

static void print_char_set(set_t *chars) {
    set_iter_t *iter = set_createiter(chars);
    printf("index set of chars = [");
    while (set_hasnext(iter)) {
        char *c = (char *)set_next(iter);
        printf("%c", c[0]);
        (set_hasnext(iter)) ? (printf(", ")) : (printf("]\n"));
    }
    set_destroyiter(iter);
}

    index->indexed_chars = set_create((cmpfunc_t)compare_chars);

    size_t len = strlen(s);
    for (size_t i = 0; i < len; i++) {
        set_add(index->indexed_chars, (void *)&s[i]);
    }

    if (ASSERT_PARSE) print_char_set(index->indexed_chars);

*/
