
/* 
 * Checks whether a query is syntactically valid. Returns a bool.
 * Edge cases still remain to be checked, but this serves as an initial filter for 
 * common errors before attempting to parse the query.
 */
static int is_valid_query(term_t *leftmost_token, char **errmsg) {
    int n_par_open = 0, n_par_close = 0, last_operator = 0;

    if (leftmost_token->right == NULL) {
        /* single term word query - boolean validity check */
        if (leftmost_token->type == WORD) {
            return 1;
        }
        *errmsg = "Single term queries must be a word.";
        return 0;
    }
    /* there's atleast 3 tokens */

    term_t *token, *curr = leftmost_token;

    if (leftmost_token->type == P_OPEN) {
        n_par_open++;
    } else if (leftmost_token->type != WORD) {
        *errmsg = "Syntax Error: Search must begin with an opening paranthesis or word.";
        return 0;
    }

    /* iterate over the rest of the query to check for errors */
    while (curr->right != NULL) {
        curr = curr->right;

        if (curr->type < 0) {
            /* current token is a paranthesis. forget the last operator. */
            last_operator = 0;

            if (curr->type == P_OPEN) {
                n_par_open++;
                if (curr->right == NULL) {
                    *errmsg = "Syntax Error: Query cannot end with an opening paranthesis.";
                    return 0;
                } else if (curr->right->type > 0) {
                    *errmsg = "Syntax Error: Queries may not begin with an operator.";
                    return 0;
                }
            } else if (curr->type == P_CLOSE) {
                n_par_close++;
                if (curr->left->type == P_OPEN) {
                    *errmsg = "Syntax Error: Empty parantheses.";
                    return 0;
                }
                if (n_par_open < n_par_close) {
                    *errmsg = "Syntax Error: Unmatched paranthesis.";
                    return 0;
                }
                if (curr->left->type > 0) {
                    *errmsg = "Syntax Error: A paranthesis may not be closed directly after an operator.";
                    return 0;
                }
            }
        } else if (curr->type > 0) {
            /* current token is an operator */
            if (last_operator) {
                if (curr->type == OP_ANDNOT) {
                    *errmsg = "Syntax Error: The ANDNOT operator cannot be chained without the use of parantheses.";
                    return 0;
                }
                if (last_operator != curr->type) {
                    *errmsg = "Syntax Error: Different types of operators must be separated by parantheses.";
                    return 0;
                }
                /* case of chained AND/OR operators. 
                 * check for correct parantheses use, if any exist. */
                int has_par_left = 0;
                int has_par_right = 0;
                /* if chained, and there is a paranthesis on one side, 
                 * require parantheses on both. (either open/close) 
                 */
                token = curr;
                while (token->left != NULL) {
                    token = token->left;
                    if (token->type < 0) {
                        has_par_left = 1;
                        break;
                    }
                }
                token = curr;
                while (token->right != NULL) {
                    token = token->right;
                    if (token->type < 0) {
                        has_par_right = 1;
                        break;
                    }
                }
                if (has_par_left != has_par_right) {
                    *errmsg = "Syntax Error: Use parantheses when chaining AND/OR operators in combined queries.";
                    return 0;
                }
            }

            if (curr->left->type > 0) {
                *errmsg = "Syntax Error: Adjacent operators";
                return 0;
            }

            /* operator cannot be enclosed in parantheses; e.g. `cat (AND) dog`, as operators alone are not a <term>. */
            if ((curr->left->type == P_OPEN) && (curr->right->type == P_CLOSE)) {
                *errmsg = "Syntax Error: Operator has no connected term.";
                return 0;
            }

            /* validate that first non-paranthesis token on left side of operator is a word */
            token = curr;
            while (token->type != WORD) {
                token = token->left;
                if ((token == NULL) || (token->type > 0)) {
                    *errmsg = "Syntax Error: 1 Operator has no connected term | Adjacent operators.";
                    return 0;
                }
            }
            /* remember current operator for when the next operator comes */
            last_operator = curr->type;
        }
    }

    /* for last token, verify that an operator is not the first non-paranthesis. */
    while (curr->type != WORD) {
        curr = curr->left;
        if ((curr == NULL) || (curr->type > 0)) {
            *errmsg = "Syntax Error: 2 Operator has no connected term | Adjacent operators.";
            return 0;
        }
    }

    if (n_par_open != n_par_close) {
        *errmsg = "Syntax Error: Opening and closing paranthesis do not match.";
        return 0;
    }

    DEBUG_PRINT("Syntax Error: Query passed all tests and should be syntactically valid.\n");
    return 1;
}



static void print_query_string(list_t *query) {
    list_iter_t *query_iter = list_createiter(query);

    char *query_term;
    while ((query_term = list_next(query_iter)) != NULL) {
        printf("%s", query_term);
    }
    printf("\n");
    list_destroyiter(query_iter);
}


/* debugging function to print result details */
static void print_results(list_t *results, list_t *query) {
    list_iter_t *iter = list_createiter(results);
    query_result_t *result;

    printf("\nFound %d results for query '", list_size(results));
    print_query_string(query);
    printf("' = {\n");

    int n = 0;
    while ((result = list_next(iter)) != NULL) {
        printf(" result #%d = {\n   score: %lf\n", n, result->score);
        printf("   path: %s\n }\n", result->path);
        n++;
    }
    printf("}\n");

    list_destroyiter(iter);
}


const int total_n_tokens = list_size(query);

// /* check the entire query for syntax errors */
// if (!is_valid_query(query, total_n_tokens, errmsg)) {
//     return NULL;
// }

list_t *results = list_create((cmpfunc_t)compare_query_results_by_score);

/* case for single term queries */
if (total_n_tokens == 1) {
    char *term = list_popfirst(query);

    if (results == NULL) {
        return NULL;
    }

    i_word_t *search_result = index_search(index, term);
    if (search_result != NULL) {
        /* iterate over i_paths that contain indexed word */
        set_iter_t *file_iter = set_createiter(search_result->i_paths_with_word);

        double score = 0.0;
        i_path_t *i_path;
        while ((i_path = set_next(file_iter)) != NULL) {
            score += 0.1;
            list_addlast(results, create_query_result(i_path->path, score));
        }
        set_destroyiter(file_iter);

        if (list_size(results) != 1) {
            /* sort results by score */
            list_sort(results);
        }
    }
    free(term);
    return results;
}


if (list_size(query) % 2 == 0) {
    /* Any given valid query will always have an odd number of tokens. Reasoning:
    * '<word> <word>' results in the indexer adding an "OR" inbetween.
    * As a consequence of this, all words must (or will, for "OR"), be connected by an operator.
    * Every operator must have adjacent terms, and parantheses must occur in multiples of 2.
    * => for every word, operator or parantheses added in addition to the 'root' word, n_tokens will 
    * be incremented by 2 if query is valid, and |tokens| will therefore never be even */
    *errmsg = "Invalid use of parantheses or operators.";
    return NULL;
}


/*
    unsigned long long t_start, t_time;
    t_start = gettime();
    if (!is_valid_query(leftmost_token, errmsg)) {
        destroy_terms(leftmost_token);
        return NULL;
    }
    t_time = (gettime() - t_start);
    printf("validity checks took a total of %llu Î¼s\n", t_time);

*/
